[
  {
    "name": "Run Started",
    "status": "success",
    "startedTimestampMs": 1740390921825,
    "logs": [
      {
        "value": "New run with ID \"adca1f1b-79b1-4cdd-91da-e88fd848c3e1\"",
        "timestampMs": 1740390921826
      },
      {
        "value": "Running workflow Main.flow",
        "timestampMs": 1740390921840
      },
      {
        "value": "Setting {{currentDate}} to \"Feb 24, 2025 9:55 AM\"",
        "timestampMs": 1740390921978
      },
      {
        "value": "Setting {{global}} to \"{\n  \"userId\": \"5bb87668-640a-42a6-b11f-ae4b523ca335\",\n  \"threadId\": \"adca1f1b-79b1-4cdd-91da-e88fd848c3e1\",\n  \"username\": \"\",\n  \"companyName\": \"\"\n}\"",
        "timestampMs": 1740390921978
      },
      {
        "value": "Setting {{$launchVariables->url}} to \"https://www.youtube.com/watch?v=pEMhPBQMNjg\"",
        "timestampMs": 1740390921979
      },
      {
        "value": "Setting {{$launchVariables->rawHtml}} to \"\"",
        "timestampMs": 1740390921979
      },
      {
        "value": "Setting {{$launchVariables->fullText}} to \"\"",
        "timestampMs": 1740390921979
      },
      {
        "value": "Setting {{$launchVariables->metadata}} to \"\"",
        "timestampMs": 1740390921979
      },
      {
        "value": "Setting {{$launchVariables->userSelection}} to \"\"",
        "timestampMs": 1740390921979
      },
      {
        "value": "Action completed",
        "timestampMs": 1740390921979
      }
    ],
    "stateSnapshot": {
      "threadId": "adca1f1b-79b1-4cdd-91da-e88fd848c3e1",
      "variables": {
        "$launchVariables->url": {
          "value": "https://www.youtube.com/watch?v=pEMhPBQMNjg"
        },
        "$launchVariables->rawHtml": {
          "value": ""
        },
        "$launchVariables->fullText": {
          "value": ""
        },
        "$launchVariables->metadata": {
          "value": ""
        },
        "$launchVariables->userSelection": {
          "value": ""
        }
      },
      "timestampMs": 1740390921979,
      "continuationToken": "c0107b5f-3f51-4d82-b850-b2b4013f133b::a8b455f9-0a7b-4a29-9ec6-7d3236f3ac16"
    },
    "relatedPosts": []
  },
  {
    "name": "Fetch YouTube Captions",
    "status": "success",
    "startedTimestampMs": 1740390922295,
    "logs": [
      {
        "value": "Fetching YouTube Captions",
        "timestampMs": 1740390922295
      },
      {
        "value": "Resolving variables",
        "timestampMs": 1740390922309
      },
      {
        "value": "Fetching captions for video: \"https://www.youtube.com/watch?v=pEMhPBQMNjg\"",
        "timestampMs": 1740390922314
      },
      {
        "value": "Saving captions to variable {{transcript}}",
        "timestampMs": 1740390925119
      },
      {
        "value": "Action completed",
        "timestampMs": 1740390925251
      }
    ],
    "stateSnapshot": {
      "threadId": "adca1f1b-79b1-4cdd-91da-e88fd848c3e1",
      "variables": {
        "$launchVariables->metadata": {
          "value": ""
        },
        "userSelection": {
          "value": ""
        },
        "$launchVariables->rawHtml": {
          "value": ""
        },
        "$launchVariables->fullText": {
          "value": ""
        },
        "url": {
          "value": "https://www.youtube.com/watch?v=pEMhPBQMNjg"
        },
        "metadata": {
          "value": ""
        },
        "$launchVariables->userSelection": {
          "value": ""
        },
        "rawHtml": {
          "value": ""
        },
        "fullText": {
          "value": ""
        },
        "$launchVariables->url": {
          "value": "https://www.youtube.com/watch?v=pEMhPBQMNjg"
        }
      },
      "timestampMs": 1740390922286,
      "continuationToken": "c0107b5f-3f51-4d82-b850-b2b4013f133b::27d13fa2-5442-498e-a41d-dc7b97f4aa3a"
    },
    "relatedPosts": []
  },
  {
    "name": "Programmatic Message",
    "status": "success",
    "startedTimestampMs": 1740390925276,
    "logs": [
      {
        "value": "Sending message: \"Watch the full video to understand the content flow and identify natural topic transitions. Create a structured summary organized by segments, with each segment containing:\r\n\r\n- A descriptive subheading that includes timestamp range and topic (e.g. \"[0:00-2:15] Introduction to Topic\")\r\n- A thorough paragraph explaining the main ideas, arguments, and key takeaways\r\n- Direct quotes in italics when they effectively illustrate important points\r\n- Relevant data, statistics, or examples in bullet form\r\n- Transition sentences between major topic changes\r\n\r\nUse heading levels to show content hierarchy:\r\n- H1 (#) for video title\r\n- H2 (##) for major segments\r\n- H3 (###) for subsections within segments\r\n\r\nFormat key terms in bold when first introduced. Use bullet points for lists of related items and numbered lists for sequential steps or processes.\r\n\r\nMaintain the video's original flow while condensing repetitive content. Focus on capturing both the high-level narrative and specific supporting details that strengthen main arguments or demonstrate concepts.\r\n\r\nReview the completed summary to ensure it provides a comprehensive yet concise representation of the video's core message and learning objectives.\r\n\r\n<transcript>\r\n{{transcript}}\r\n</transcript>\"",
        "timestampMs": 1740390925276
      },
      {
        "value": "Loading message history",
        "timestampMs": 1740390925278
      },
      {
        "value": "Preparing to query claude-3-5-haiku at 0.6Â° with a maximum response size of 8,192 tokens",
        "timestampMs": 1740390925362
      },
      {
        "value": "Resolving variables",
        "timestampMs": 1740390925381
      },
      {
        "value": "Sending resolved message: \"Watch the full video to understand the content flow and identify natural topic transitions. Create a structured summary organized by segments, with each segment containing:\r\n\r\n- A descriptive subheading that includes timestamp range and topic (e.g. \"[0:00-2:15] Introduction to Topic\")\r\n- A thorough paragraph explaining the main ideas, arguments, and key takeaways\r\n- Direct quotes in italics when they effectively illustrate important points\r\n- Relevant data, statistics, or examples in bullet form\r\n- Transition sentences between major topic changes\r\n\r\nUse heading levels to show content hierarchy:\r\n- H1 (#) for video title\r\n- H2 (##) for major segments\r\n- H3 (###) for subsections within segments\r\n\r\nFormat key terms in bold when first introduced. Use bullet points for lists of related items and numbered lists for sequential steps or processes.\r\n\r\nMaintain the video's original flow while condensing repetitive content. Focus on capturing both the high-level narrative and specific supporting details that strengthen main arguments or demonstrate concepts.\r\n\r\nReview the completed summary to ensure it provides a comprehensive yet concise representation of the video's core message and learning objectives.\r\n\r\n<transcript>\r\n[00:00] Alright in this video, I want to teach you one of the most common, useful, simple\n\n[00:05] patterns that you can use in LangGraph.\n\n[00:08] And this is the pattern around creating ReAct agents, but\n\n[00:12] doing it with function calling.\n\n[00:14] So, this is a fundamental thing that I see a lot of people make mistakes when\n\n[00:18] they're designing their agents is that they end up having lots of different\n\n[00:22] nodes for doing different sorts of calls and function calls and stuff like that.\n\n[00:27] And they try to have something like a reason where it decides if it's\n\n[00:30] going to use math, it's going to use search, if it's going to use this.\n\n[00:34] And they end up with a graph, that's really complicated.\n\n[00:36] What you realize after this video is that really, you can just do all of this with\n\n[00:41] making one node yourself and then using some prebuilt functions from LangGraph.\n\n[00:47] So here we're going to basically have out reasoner node, which is going to\n\n[00:51] decide if we're going to use a tool.\n\n[00:52] If we're going to use a tool, no matter what the tool we're\n\n[00:55] going to go to the tool node.\n\n[00:56] we're going to take the output of that tool, feed it back to the reasoner.\n\n[01:00] If it decides it needs another tool, it will go again to the tool note.\n\n[01:04] if it decides that it doesn't need a tool at all, it will just go to the end.\n\n[01:08] This is one of the simplest patterns, but it's one of the most\n\n[01:11] useful patterns that you can use.\n\n[01:13] I'll start off by showing you a simple version of this.\n\n[01:15] And then we'll add in a custom tool and then we'll also make\n\n[01:18] a custom state graph for this.\n\n[01:19] So you can see how you can take the basics and then end up with\n\n[01:22] something that's fully customized for what you want at the end here.\n\n[01:26] Okay, so let's jump in and have a look at the code.\n\n[01:28] So, first off you can see, I'm just bringing in the standard\n\n[01:31] stuff for LangGraph and LangChain.\n\n[01:34] We're going to use Duck Duck Go in here.\n\n[01:36] And we're going to start off with just a really simple ReAct function calling\n\n[01:39] pattern of doing a search and math.\n\n[01:43] So it's going to be sort of an extension of one of the examples\n\n[01:46] that they give in their docs.\n\n[01:48] Before we do that, I wanted to show you the traditional ReAct prompt, you\n\n[01:53] basically are doing something where you're asking it to decide if you want to\n\n[01:57] use tools, you're passing in the tools.\n\n[02:00] So it knows what tools that has access to.\n\n[02:03] And then you ask it, an action step that's going to take, and it's going\n\n[02:06] to provide a action input for that.\n\n[02:09] So while technically what we're doing is not exactly the ReAct prompt,\n\n[02:14] we're doing the same thing with the function calling in here right.\n\n[02:18] And to take advantage of that in LangGraph, we need\n\n[02:20] to set it up the right way.\n\n[02:22] So first off, we're just gonna bring in a standard model in here.\n\n[02:26] We've just got a chat model and you don't have to use OpenAI.\n\n[02:28] You could use some of the other ones in here as well.\n\n[02:31] We're then going to set up some tools.\n\n[02:33] So these are the tools taken from their docs.\n\n[02:35] So you've got multiply.\n\n[02:37] You've got addition.\n\n[02:38] You've got divide in there.\n\n[02:40] and then I'm going to throw in a different tool that we're going to\n\n[02:43] basically just bring in the standard sort of Duck Duck Go search tool.\n\n[02:48] And this is the simplest search tool that you can use.\n\n[02:50] in a future video, I will talk a lot more about custom tools.\n\n[02:55] And I will talk a lot more about like crafting your own tools.\n\n[02:57] Although later on we'll actually make a little custom tool in here as well.\n\n[03:01] So we've got Duck Duck Go search.\n\n[03:03] You can see if I type in like how old is Brad Pitt?\n\n[03:06] We're going to get a bunch of information back about Brad Pitt in there.\n\n[03:10] And we can see that in that information is going to be his current age.\n\n[03:14] So next up, we want to bind those tools to the LLM, So that the definitions of\n\n[03:20] these tools, the schemas, et cetera, are going to go into the LLM so it\n\n[03:25] can use them for function calling.\n\n[03:26] So it can decide, okay, this is the function, or this is\n\n[03:29] the tool that I want to use.\n\n[03:31] And remember, tool use and function calling are basically the same thing.\n\n[03:35] It's just deciding which tool does it want to call, which is\n\n[03:39] the same thing as deciding which function at wants to call in here.\n\n[03:43] All right.\n\n[03:43] We set up a simple system message where we're going to have your helpful,\n\n[03:47] assistant performing using search and performing arithmetic on a set of inputs.\n\n[03:52] and then we've got the more sort of LangGraph stuff.\n\n[03:55] So the LangGraph stuff we need to basically define the graph.\n\n[03:59] We define the nodes.\n\n[04:01] We define the edges here.\n\n[04:03] Now the whole thing that I'm trying to show you with this is that you don't\n\n[04:07] need a lot of nodes to do this pattern.\n\n[04:10] So you can see that the node that I've got here is this one node the reasoner.\n\n[04:14] This is going to take in a message state.\n\n[04:16] So rather than using a type dictionary where we define everything that's going\n\n[04:21] to be in the state, LangGraph has made this special state called a message state.\n\n[04:26] And really, if we hover over it, you can see it itself is just a typed dict where\n\n[04:31] it's basically adding in this message.\n\n[04:34] and it's basically setting it up so that each time that we write\n\n[04:38] to it, we're not overwriting it.\n\n[04:39] We're just adding to the list in there.\n\n[04:42] So you can see that this message state, we can take the LLM that we do defined,\n\n[04:47] we can pass in the system message.\n\n[04:50] And whatever messages that the model started off with.\n\n[04:53] So we're going to pump in a message in there at the start.\n\n[04:56] And then we can just call that.\n\n[04:58] And then we can return that to the messages variable on here.\n\n[05:02] And we can see that, an addable values dict in here.\n\n[05:05] So that basically it's going to, whatever the response is from this, it's going to\n\n[05:09] basically be pushed onto this messages thing here and then that node is done.\n\n[05:15] It goes to the next node, or really it's going to go to the\n\n[05:17] next edge that we're going to see.\n\n[05:19] All right, so our nodes are done.\n\n[05:21] Now we need to build the graph.\n\n[05:22] So the graph here is being built where they're basically just\n\n[05:25] taking in the message state.\n\n[05:27] So this is like the pre-made dictionary for this.\n\n[05:31] We're then going to add the nodes to this.\n\n[05:33] So we're just adding, a reasoner node and we're adding in a tools node.\n\n[05:37] So where did this tools node come from?\n\n[05:40] Okay.\n\n[05:40] So this is one of the prebuilt things here.\n\n[05:42] So we're making use of two prebuilt components from LangGraph.\n\n[05:47] One is a tools node.\n\n[05:48] and can see that we just instantiate that by passing in\n\n[05:51] the tools that we had up here.\n\n[05:54] Right.\n\n[05:54] We've got the tools there.\n\n[05:56] So it knows what tools are in there.\n\n[05:58] It knows what tools to call, et cetera as you go through.\n\n[06:02] The other prebuilt thing that we've got is this tool's condition.\n\n[06:06] This is just a function that we're going to use in an a conditional edge so that\n\n[06:11] when we adding our edges, So to start we're going to go to the reasoner, this\n\n[06:14] is the node that basically decides, you know, sends it off and gets back with it.\n\n[06:19] We're going to use a function call or not a function call.\n\n[06:22] So if we just said hello or something like that, it's obviously not going\n\n[06:24] to use a function called there.\n\n[06:26] but if it's going to use a function call, we can see that, okay, we're\n\n[06:29] going to come out of that and we've got this conditional edge.\n\n[06:32] Now, normally the conditional edge, we would decide, okay, we're going to this\n\n[06:38] particular node or this other node here.\n\n[06:40] Now we're using this tools condition.\n\n[06:43] And if you look in the actual source code, you'll see that the tool's\n\n[06:45] condition really is no different than any conditional edge that we,\n\n[06:50] create ourself where it's just looking at the last message that got back\n\n[06:55] and if it was an AI message, it's basically saying, okay, was this using\n\n[07:00] tools or was this not using tools?\n\n[07:03] If it is using tools?\n\n[07:04] It's going to turn back the string tools and we can see that then\n\n[07:08] it's going to route it to the tool called or the tools node.\n\n[07:12] And if it isn't, it's going to basically just send it to the end.\n\n[07:15] So this is what's going on in here.\n\n[07:18] So it can appear a bit like it's voodoo, that you don't know what's\n\n[07:21] going on in there, but actually really, it's quite simple what\n\n[07:24] this is actually doing in here.\n\n[07:26] Next up, we've basically got our last edge, which will always\n\n[07:29] go from tools back to reasoner.\n\n[07:31] So once we, get told to do the function call and do a search, we go off to tools.\n\n[07:37] We do the search, we get the results of the search.\n\n[07:39] We pass it back to the model.\n\n[07:41] And because we're passing in the history as we go along with this, right.\n\n[07:45] We're passing in all of these messages.\n\n[07:48] It knows, oh, okay, I asked for this particular function call and this is\n\n[07:52] the result that I got back in there.\n\n[07:55] So when we put it all together, you can see that with just got\n\n[07:58] a very simple graph, right?\n\n[08:00] We're just going start to the reasoner, reasoner if it say\n\n[08:03] hello, we'll just go to end.\n\n[08:05] If you've got a tool use, it we'll go to tools and then we'll pass that back.\n\n[08:10] Now here's the thing is if it needs another tool call,\n\n[08:13] it will then just go tools.\n\n[08:15] So it's got this loop going on here.\n\n[08:18] And we can see this when we come and run it that now if I ask it, okay,\n\n[08:22] what is two times Brad Pitt's age?\n\n[08:25] So we know that we've got searched that can get Brad Pitt's age.\n\n[08:28] We know that we've got arithmetic that can put it together.\n\n[08:32] Sure enough, when we look at the messages out, we can see that what did it first do?\n\n[08:36] It first went and did a query to search on Duck Duck Go Brad Pitt's age, right?\n\n[08:41] It got that result back.\n\n[08:43] This is the tool message that it got back.\n\n[08:45] we can see then it decided his age is 60, which I think is correct\n\n[08:50] based on December 16th, 1963.\n\n[08:53] Even though it's saying 61 here.\n\n[08:55] And it's basically done two times that's the key thing I want you to see there.\n\n[08:59] And then it comes back with, the answer of that is 120.\n\n[09:02] And so we get this answer out, two times Brad Pitt's age, is 120 there.\n\n[09:06] So this idea of this tool loop going on is the key thing.\n\n[09:11] Now, if I only needed one tool, it would just use that and it would then end,\n\n[09:15] or after the final sort of call there.\n\n[09:18] Let's look a little bit more advanced way of adding our own custom tool.\n\n[09:22] So I'm going to keep the tools that we've got here.\n\n[09:24] I'm going to make a Yahoo finance tool.\n\n[09:27] So this is basically just a get a stock price based on a ticker symbol.\n\n[09:32] You can see that, okay, I'm just passing this in here.\n\n[09:35] I was experimenting with different things passing in here.\n\n[09:38] It seems to work well when you pass in the args that you want\n\n[09:41] as well, rather than just this.\n\n[09:44] So what we'r e going to do is we're going to get the ticker.\n\n[09:46] We're going to look up the stock.\n\n[09:47] We're going to get the previous close for that and return it.\n\n[09:50] You can see here if we test it.\n\n[09:52] we're going to get out the last Apple price in there.\n\n[09:55] Now LangChain has a Yahoo finance tool.\n\n[10:00] but I find this not to work very well.\n\n[10:02] You end up getting lots of news back other things.\n\n[10:05] It tends to confuse things in there.\n\n[10:07] All right.\n\n[10:08] This time, I want to show you, is that what if we wanted to do\n\n[10:12] things a little bit differently?\n\n[10:14] What if we want it to make our own node and our own graph in there.\n\n[10:17] So not using they're pre-made graph in there.\n\n[10:21] So okay, making the graph, let me jump around a little bit.\n\n[10:23] The graph here, I'm going to say, okay, we've got a query that we start things\n\n[10:27] off where we're going to have the messages exactly like they have in there.\n\n[10:31] This whole idea of an annotated list.\n\n[10:34] and this ad operator, you'll see this used a lot for intermediate steps.\n\n[10:38] but this ad operator also can just add in all the messages we've got.\n\n[10:42] And then we've got our final answer out.\n\n[10:44] you could imagine we could add some things like finance in there.\n\n[10:47] If we want it to save the numbers and, push them off to something\n\n[10:50] or do something else with it.\n\n[10:52] but I want to show you that can make your own custom graph dictionary there.\n\n[10:56] And then using this on our reasoner node.\n\n[10:59] Cause I just want to have the same number of nodes that we had before.\n\n[11:02] I'm not going to try and make a lot of them.\n\n[11:05] we're going to basically pull the query.\n\n[11:07] we're going to pull the messages.\n\n[11:09] we're then going to just put in the system message.\n\n[11:11] So this is the same as before, except I've added in you've also got\n\n[11:15] access to the Yahoo finance tool.\n\n[11:17] And then we've basically got our message, which we're going to\n\n[11:20] wrap as a human message in there.\n\n[11:22] We're going to append that to the messages.\n\n[11:24] So our message is going to have whatever our query is going in.\n\n[11:28] and then we're going to invoke it just like we did before, right.\n\n[11:31] With this LLM with tools, in there.\n\n[11:34] We set up our tools exactly the same as before.\n\n[11:37] We're just adding in this, get stock price.\n\n[11:40] we set up the LLM with and bind the tools again.\n\n[11:44] You can see if we look at the tools, we can see the new tool that we've added in\n\n[11:48] here is this fifth tool is this, get stock price and ticker and stuff like that.\n\n[11:53] We can see, okay, what's going through to the actual model there.\n\n[11:57] All right.\n\n[11:57] I've talked about, we set up our graph state in there.\n\n[12:01] Finally, we just assemble everything in here.\n\n[12:03] So I'm just calling this workflow where we're creating our state graph from\n\n[12:07] this class that we defined up here.\n\n[12:10] We add in our node for a reasoner.\n\n[12:13] We add in the tools I'm still using their pre-made, tool note,\n\n[12:16] very useful for doing that.\n\n[12:18] and then I kick it off exactly the same as using the same conditional edge.\n\n[12:22] and putting it together and you can see the graph is going to be the same as well.\n\n[12:25] It's just, I've just now got the freedom.\n\n[12:28] If I want it to not come out with end here, I could go to other nodes\n\n[12:32] and do other things in there as well.\n\n[12:35] All right, let's try it out.\n\n[12:36] So what is two times Brad Pitt's age?\n\n[12:39] Sure enough.\n\n[12:39] We get the same result back here.\n\n[12:41] I'm just looking at the last message on the stack there.\n\n[12:45] if I ask it, what is the price of Apple?\n\n[12:47] you can see sure enough, it just goes for get stock price.\n\n[12:51] uses the function calling returns that if I ask it, what is the stock price of\n\n[12:56] the company that Jensen Huang is CEO of?\n\n[12:59] So now we're starting to do multiple calls to this tool, but we're still\n\n[13:04] just using that one tool note each time.\n\n[13:06] and cause he's shown off, it says, okay.\n\n[13:08] what is stock price?\n\n[13:10] We've got Duck Duck Go search first asking Jensen Huang CEO company.\n\n[13:15] And we can see that, sure enough, it gets back from Denny's\n\n[13:17] dishwasher to CEO of Nvidia.\n\n[13:19] So it works out that it's Nvidia.\n\n[13:21] it then does a stock price call on Nvidia.\n\n[13:25] It gets back the price for that.\n\n[13:27] And then it finally gives it, then it goes back to the reasoner where it phrases\n\n[13:31] it in nice natural language for us.\n\n[13:33] The stock price of Nvidia, the company where Jensen Huang is the CEO, is this.\n\n[13:38] Again, if I wanted to use more tools, I can ask it what would be the price\n\n[13:42] of Nvidia's stock if it doubles?\n\n[13:45] Again, it's got to basically get this.\n\n[13:47] It's got this, as then using our math tools in there.\n\n[13:50] So very quickly, you can see that this really small little agent that basically\n\n[13:56] is just doing like a ReAct pattern of looping through, but doing it with\n\n[14:00] function calling is able to get a whole bunch of information and return this.\n\n[14:05] So this is something that you could even use as a sub graph where you could\n\n[14:09] basically have other graphs calling to this, you could have things in your\n\n[14:13] app that just need to know certain information, call out to this, et cetera.\n\n[14:18] And for a pretty small amount of code you've now got something\n\n[14:21] that can use a lot of different tools that you have in there.\n\n[14:24] And you'd be able to call them in a loop and then give a nice\n\n[14:26] natural language answer out there.\n\n[14:29] So, if you want using this pattern already in your agents, you certainly should be.\n\n[14:33] It's one of the easiest patterns to use.\n\n[14:35] And it generally works very well All right.\n\n[14:37] As always, if you've got any questions, please put them in the comments below.\n\n[14:40] If you found the video useful, please click like and subscribe.\n\n[14:43] And I will talk to you in the next video.\n\n[14:45] Bye for now.\r\n</transcript>\"",
        "timestampMs": 1740390925536
      },
      {
        "value": "Running model",
        "timestampMs": 1740390925536
      },
      {
        "value": "Received first response token",
        "timestampMs": 1740390927413
      },
      {
        "value": "Received full result: 6,742 tokens (6,141 sent, 601 received) at 35.235 tokens/second",
        "timestampMs": 1740390942594
      },
      {
        "value": "Received result: \"# LangGraph ReAct Agent Pattern: Function Calling and Tool Use\n\n## [0:00-1:22] Introduction to ReAct Agent Pattern\n\nThe video introduces a fundamental pattern in LangGraph for creating **ReAct agents** using function calling. The key insight is simplifying agent design by:\n\n- Avoiding complex multi-node graphs\n- Using a single reasoner node\n- Leveraging prebuilt LangGraph functions\n- Creating a straightforward tool-use loop\n\n*\"What you realize after this video is that really, you can just do all of this with making one node yourself and then using some prebuilt functions from LangGraph.\"*\n\nCore pattern components:\n1. Reasoner node decides tool usage\n2. Tool node executes specific functions\n3. Continuous loop between reasoner and tool nodes\n4. Automatic termination when no tools are needed\n\n## [1:28-3:10] Setting Up Tools and Language Model\n\nThe demonstration uses:\n- OpenAI chat model\n- Predefined tools:\n  * Multiplication\n  * Addition\n  * Division\n  * Duck Duck Go search\n\n**Key Setup Steps**:\n1. Bind tools to the language model\n2. Create system message defining agent capabilities\n3. Enable function calling for tool selection\n\n*\"Tool use and function calling are basically the same thing - deciding which tool or function to call.\"*\n\n## [3:55-7:55] LangGraph Graph Construction\n\n### Graph Components\n- **Message State**: Specialized dictionary for storing conversation history\n- Nodes:\n  * Reasoner node\n  * Prebuilt tools node\n- Conditional edges for routing\n\n### Workflow\n1. Start at reasoner node\n2. Determine tool usage\n3. Route to tools node if needed\n4. Return results to reasoner\n5. Repeat or terminate\n\n*\"This idea of this tool loop going on is the key thing.\"*\n\n## [9:22-14:26] Advanced Example: Custom Tool Integration\n\n### Custom Yahoo Finance Tool\n- Retrieve stock prices using ticker symbols\n- Demonstrate flexibility of agent pattern\n- Show multi-step reasoning capabilities\n\n**Example Scenarios**:\n- Calculate two times Brad Pitt's age\n- Find stock price of Nvidia\n- Perform complex multi-tool queries\n\n## Key Takeaways\n\n1. Simplify agent design with minimal nodes\n2. Leverage function calling for tool selection\n3. Create flexible, reusable agent patterns\n4. Enable complex reasoning with simple architecture\n\n*\"For a pretty small amount of code you've now got something that can use a lot of different tools... and give a nice natural language answer.\"*\n\n## Recommended Practices\n\n- Use prebuilt LangGraph components\n- Design agents with single reasoner node\n- Implement conditional routing\n- Focus on tool flexibility\"",
        "timestampMs": 1740390942619
      },
      {
        "value": "Action completed",
        "timestampMs": 1740390942619
      }
    ],
    "stateSnapshot": {
      "threadId": "adca1f1b-79b1-4cdd-91da-e88fd848c3e1",
      "variables": {
        "$launchVariables->metadata": {
          "value": ""
        },
        "userSelection": {
          "value": ""
        },
        "$launchVariables->rawHtml": {
          "value": ""
        },
        "$launchVariables->fullText": {
          "value": ""
        },
        "url": {
          "value": "https://www.youtube.com/watch?v=pEMhPBQMNjg"
        },
        "metadata": {
          "value": ""
        },
        "$launchVariables->userSelection": {
          "value": ""
        },
        "rawHtml": {
          "value": ""
        },
        "transcript": {
          "value": "",
          "remoteRef": "lfs/u5bb87668-640a-42a6-b11f-ae4b523ca335/tadca1f1b-79b1-4cdd-91da-e88fd848c3e1/transcript.json"
        },
        "fullText": {
          "value": ""
        },
        "$launchVariables->url": {
          "value": "https://www.youtube.com/watch?v=pEMhPBQMNjg"
        }
      },
      "timestampMs": 1740390925268,
      "continuationToken": "c0107b5f-3f51-4d82-b850-b2b4013f133b::a3cb5849-95e1-4168-bd7d-c8c31202813e"
    },
    "relatedPosts": [
      {
        "id": "855bf666-1181-4c96-a12a-d5fd216b2853",
        "source": {
          "workflowId": "c0107b5f-3f51-4d82-b850-b2b4013f133b",
          "stepId": "a3cb5849-95e1-4168-bd7d-c8c31202813e",
          "logId": "a2aa8407-0a6e-4ec8-8fd5-0de243138841",
          "idempotencyKey": null
        },
        "type": "chatMessage",
        "dateCreated": "2025-02-24T09:55:25.364724+00:00",
        "dateLastUpdated": "2025-02-24T09:55:25.364724+00:00",
        "selectedVariantId": null,
        "chatMessage": {
          "loggingEnabled": false,
          "dateSent": 1740390925,
          "_presentationInfo": {
            "messageSource": "automation"
          },
          "_metadata": {
            "groupId": "fa08bddf-60b1-444f-9cfc-35fd0f68aa71",
            "workflowId": "c0107b5f-3f51-4d82-b850-b2b4013f133b",
            "automationId": "a3cb5849-95e1-4168-bd7d-c8c31202813e"
          },
          "tokensUsed": 6141,
          "content": "Watch the full video to understand the content flow and identify natural topic transitions. Create a structured summary organized by segments, with each segment containing:\r\n\r\n- A descriptive subheading that includes timestamp range and topic (e.g. \"[0:00-2:15] Introduction to Topic\")\r\n- A thorough paragraph explaining the main ideas, arguments, and key takeaways\r\n- Direct quotes in italics when they effectively illustrate important points\r\n- Relevant data, statistics, or examples in bullet form\r\n- Transition sentences between major topic changes\r\n\r\nUse heading levels to show content hierarchy:\r\n- H1 (#) for video title\r\n- H2 (##) for major segments\r\n- H3 (###) for subsections within segments\r\n\r\nFormat key terms in bold when first introduced. Use bullet points for lists of related items and numbered lists for sequential steps or processes.\r\n\r\nMaintain the video's original flow while condensing repetitive content. Focus on capturing both the high-level narrative and specific supporting details that strengthen main arguments or demonstrate concepts.\r\n\r\nReview the completed summary to ensure it provides a comprehensive yet concise representation of the video's core message and learning objectives.\r\n\r\n<transcript>\r\n[00:00] Alright in this video, I want to teach you one of the most common, useful, simple\n\n[00:05] patterns that you can use in LangGraph.\n\n[00:08] And this is the pattern around creating ReAct agents, but\n\n[00:12] doing it with function calling.\n\n[00:14] So, this is a fundamental thing that I see a lot of people make mistakes when\n\n[00:18] they're designing their agents is that they end up having lots of different\n\n[00:22] nodes for doing different sorts of calls and function calls and stuff like that.\n\n[00:27] And they try to have something like a reason where it decides if it's\n\n[00:30] going to use math, it's going to use search, if it's going to use this.\n\n[00:34] And they end up with a graph, that's really complicated.\n\n[00:36] What you realize after this video is that really, you can just do all of this with\n\n[00:41] making one node yourself and then using some prebuilt functions from LangGraph.\n\n[00:47] So here we're going to basically have out reasoner node, which is going to\n\n[00:51] decide if we're going to use a tool.\n\n[00:52] If we're going to use a tool, no matter what the tool we're\n\n[00:55] going to go to the tool node.\n\n[00:56] we're going to take the output of that tool, feed it back to the reasoner.\n\n[01:00] If it decides it needs another tool, it will go again to the tool note.\n\n[01:04] if it decides that it doesn't need a tool at all, it will just go to the end.\n\n[01:08] This is one of the simplest patterns, but it's one of the most\n\n[01:11] useful patterns that you can use.\n\n[01:13] I'll start off by showing you a simple version of this.\n\n[01:15] And then we'll add in a custom tool and then we'll also make\n\n[01:18] a custom state graph for this.\n\n[01:19] So you can see how you can take the basics and then end up with\n\n[01:22] something that's fully customized for what you want at the end here.\n\n[01:26] Okay, so let's jump in and have a look at the code.\n\n[01:28] So, first off you can see, I'm just bringing in the standard\n\n[01:31] stuff for LangGraph and LangChain.\n\n[01:34] We're going to use Duck Duck Go in here.\n\n[01:36] And we're going to start off with just a really simple ReAct function calling\n\n[01:39] pattern of doing a search and math.\n\n[01:43] So it's going to be sort of an extension of one of the examples\n\n[01:46] that they give in their docs.\n\n[01:48] Before we do that, I wanted to show you the traditional ReAct prompt, you\n\n[01:53] basically are doing something where you're asking it to decide if you want to\n\n[01:57] use tools, you're passing in the tools.\n\n[02:00] So it knows what tools that has access to.\n\n[02:03] And then you ask it, an action step that's going to take, and it's going\n\n[02:06] to provide a action input for that.\n\n[02:09] So while technically what we're doing is not exactly the ReAct prompt,\n\n[02:14] we're doing the same thing with the function calling in here right.\n\n[02:18] And to take advantage of that in LangGraph, we need\n\n[02:20] to set it up the right way.\n\n[02:22] So first off, we're just gonna bring in a standard model in here.\n\n[02:26] We've just got a chat model and you don't have to use OpenAI.\n\n[02:28] You could use some of the other ones in here as well.\n\n[02:31] We're then going to set up some tools.\n\n[02:33] So these are the tools taken from their docs.\n\n[02:35] So you've got multiply.\n\n[02:37] You've got addition.\n\n[02:38] You've got divide in there.\n\n[02:40] and then I'm going to throw in a different tool that we're going to\n\n[02:43] basically just bring in the standard sort of Duck Duck Go search tool.\n\n[02:48] And this is the simplest search tool that you can use.\n\n[02:50] in a future video, I will talk a lot more about custom tools.\n\n[02:55] And I will talk a lot more about like crafting your own tools.\n\n[02:57] Although later on we'll actually make a little custom tool in here as well.\n\n[03:01] So we've got Duck Duck Go search.\n\n[03:03] You can see if I type in like how old is Brad Pitt?\n\n[03:06] We're going to get a bunch of information back about Brad Pitt in there.\n\n[03:10] And we can see that in that information is going to be his current age.\n\n[03:14] So next up, we want to bind those tools to the LLM, So that the definitions of\n\n[03:20] these tools, the schemas, et cetera, are going to go into the LLM so it\n\n[03:25] can use them for function calling.\n\n[03:26] So it can decide, okay, this is the function, or this is\n\n[03:29] the tool that I want to use.\n\n[03:31] And remember, tool use and function calling are basically the same thing.\n\n[03:35] It's just deciding which tool does it want to call, which is\n\n[03:39] the same thing as deciding which function at wants to call in here.\n\n[03:43] All right.\n\n[03:43] We set up a simple system message where we're going to have your helpful,\n\n[03:47] assistant performing using search and performing arithmetic on a set of inputs.\n\n[03:52] and then we've got the more sort of LangGraph stuff.\n\n[03:55] So the LangGraph stuff we need to basically define the graph.\n\n[03:59] We define the nodes.\n\n[04:01] We define the edges here.\n\n[04:03] Now the whole thing that I'm trying to show you with this is that you don't\n\n[04:07] need a lot of nodes to do this pattern.\n\n[04:10] So you can see that the node that I've got here is this one node the reasoner.\n\n[04:14] This is going to take in a message state.\n\n[04:16] So rather than using a type dictionary where we define everything that's going\n\n[04:21] to be in the state, LangGraph has made this special state called a message state.\n\n[04:26] And really, if we hover over it, you can see it itself is just a typed dict where\n\n[04:31] it's basically adding in this message.\n\n[04:34] and it's basically setting it up so that each time that we write\n\n[04:38] to it, we're not overwriting it.\n\n[04:39] We're just adding to the list in there.\n\n[04:42] So you can see that this message state, we can take the LLM that we do defined,\n\n[04:47] we can pass in the system message.\n\n[04:50] And whatever messages that the model started off with.\n\n[04:53] So we're going to pump in a message in there at the start.\n\n[04:56] And then we can just call that.\n\n[04:58] And then we can return that to the messages variable on here.\n\n[05:02] And we can see that, an addable values dict in here.\n\n[05:05] So that basically it's going to, whatever the response is from this, it's going to\n\n[05:09] basically be pushed onto this messages thing here and then that node is done.\n\n[05:15] It goes to the next node, or really it's going to go to the\n\n[05:17] next edge that we're going to see.\n\n[05:19] All right, so our nodes are done.\n\n[05:21] Now we need to build the graph.\n\n[05:22] So the graph here is being built where they're basically just\n\n[05:25] taking in the message state.\n\n[05:27] So this is like the pre-made dictionary for this.\n\n[05:31] We're then going to add the nodes to this.\n\n[05:33] So we're just adding, a reasoner node and we're adding in a tools node.\n\n[05:37] So where did this tools node come from?\n\n[05:40] Okay.\n\n[05:40] So this is one of the prebuilt things here.\n\n[05:42] So we're making use of two prebuilt components from LangGraph.\n\n[05:47] One is a tools node.\n\n[05:48] and can see that we just instantiate that by passing in\n\n[05:51] the tools that we had up here.\n\n[05:54] Right.\n\n[05:54] We've got the tools there.\n\n[05:56] So it knows what tools are in there.\n\n[05:58] It knows what tools to call, et cetera as you go through.\n\n[06:02] The other prebuilt thing that we've got is this tool's condition.\n\n[06:06] This is just a function that we're going to use in an a conditional edge so that\n\n[06:11] when we adding our edges, So to start we're going to go to the reasoner, this\n\n[06:14] is the node that basically decides, you know, sends it off and gets back with it.\n\n[06:19] We're going to use a function call or not a function call.\n\n[06:22] So if we just said hello or something like that, it's obviously not going\n\n[06:24] to use a function called there.\n\n[06:26] but if it's going to use a function call, we can see that, okay, we're\n\n[06:29] going to come out of that and we've got this conditional edge.\n\n[06:32] Now, normally the conditional edge, we would decide, okay, we're going to this\n\n[06:38] particular node or this other node here.\n\n[06:40] Now we're using this tools condition.\n\n[06:43] And if you look in the actual source code, you'll see that the tool's\n\n[06:45] condition really is no different than any conditional edge that we,\n\n[06:50] create ourself where it's just looking at the last message that got back\n\n[06:55] and if it was an AI message, it's basically saying, okay, was this using\n\n[07:00] tools or was this not using tools?\n\n[07:03] If it is using tools?\n\n[07:04] It's going to turn back the string tools and we can see that then\n\n[07:08] it's going to route it to the tool called or the tools node.\n\n[07:12] And if it isn't, it's going to basically just send it to the end.\n\n[07:15] So this is what's going on in here.\n\n[07:18] So it can appear a bit like it's voodoo, that you don't know what's\n\n[07:21] going on in there, but actually really, it's quite simple what\n\n[07:24] this is actually doing in here.\n\n[07:26] Next up, we've basically got our last edge, which will always\n\n[07:29] go from tools back to reasoner.\n\n[07:31] So once we, get told to do the function call and do a search, we go off to tools.\n\n[07:37] We do the search, we get the results of the search.\n\n[07:39] We pass it back to the model.\n\n[07:41] And because we're passing in the history as we go along with this, right.\n\n[07:45] We're passing in all of these messages.\n\n[07:48] It knows, oh, okay, I asked for this particular function call and this is\n\n[07:52] the result that I got back in there.\n\n[07:55] So when we put it all together, you can see that with just got\n\n[07:58] a very simple graph, right?\n\n[08:00] We're just going start to the reasoner, reasoner if it say\n\n[08:03] hello, we'll just go to end.\n\n[08:05] If you've got a tool use, it we'll go to tools and then we'll pass that back.\n\n[08:10] Now here's the thing is if it needs another tool call,\n\n[08:13] it will then just go tools.\n\n[08:15] So it's got this loop going on here.\n\n[08:18] And we can see this when we come and run it that now if I ask it, okay,\n\n[08:22] what is two times Brad Pitt's age?\n\n[08:25] So we know that we've got searched that can get Brad Pitt's age.\n\n[08:28] We know that we've got arithmetic that can put it together.\n\n[08:32] Sure enough, when we look at the messages out, we can see that what did it first do?\n\n[08:36] It first went and did a query to search on Duck Duck Go Brad Pitt's age, right?\n\n[08:41] It got that result back.\n\n[08:43] This is the tool message that it got back.\n\n[08:45] we can see then it decided his age is 60, which I think is correct\n\n[08:50] based on December 16th, 1963.\n\n[08:53] Even though it's saying 61 here.\n\n[08:55] And it's basically done two times that's the key thing I want you to see there.\n\n[08:59] And then it comes back with, the answer of that is 120.\n\n[09:02] And so we get this answer out, two times Brad Pitt's age, is 120 there.\n\n[09:06] So this idea of this tool loop going on is the key thing.\n\n[09:11] Now, if I only needed one tool, it would just use that and it would then end,\n\n[09:15] or after the final sort of call there.\n\n[09:18] Let's look a little bit more advanced way of adding our own custom tool.\n\n[09:22] So I'm going to keep the tools that we've got here.\n\n[09:24] I'm going to make a Yahoo finance tool.\n\n[09:27] So this is basically just a get a stock price based on a ticker symbol.\n\n[09:32] You can see that, okay, I'm just passing this in here.\n\n[09:35] I was experimenting with different things passing in here.\n\n[09:38] It seems to work well when you pass in the args that you want\n\n[09:41] as well, rather than just this.\n\n[09:44] So what we'r e going to do is we're going to get the ticker.\n\n[09:46] We're going to look up the stock.\n\n[09:47] We're going to get the previous close for that and return it.\n\n[09:50] You can see here if we test it.\n\n[09:52] we're going to get out the last Apple price in there.\n\n[09:55] Now LangChain has a Yahoo finance tool.\n\n[10:00] but I find this not to work very well.\n\n[10:02] You end up getting lots of news back other things.\n\n[10:05] It tends to confuse things in there.\n\n[10:07] All right.\n\n[10:08] This time, I want to show you, is that what if we wanted to do\n\n[10:12] things a little bit differently?\n\n[10:14] What if we want it to make our own node and our own graph in there.\n\n[10:17] So not using they're pre-made graph in there.\n\n[10:21] So okay, making the graph, let me jump around a little bit.\n\n[10:23] The graph here, I'm going to say, okay, we've got a query that we start things\n\n[10:27] off where we're going to have the messages exactly like they have in there.\n\n[10:31] This whole idea of an annotated list.\n\n[10:34] and this ad operator, you'll see this used a lot for intermediate steps.\n\n[10:38] but this ad operator also can just add in all the messages we've got.\n\n[10:42] And then we've got our final answer out.\n\n[10:44] you could imagine we could add some things like finance in there.\n\n[10:47] If we want it to save the numbers and, push them off to something\n\n[10:50] or do something else with it.\n\n[10:52] but I want to show you that can make your own custom graph dictionary there.\n\n[10:56] And then using this on our reasoner node.\n\n[10:59] Cause I just want to have the same number of nodes that we had before.\n\n[11:02] I'm not going to try and make a lot of them.\n\n[11:05] we're going to basically pull the query.\n\n[11:07] we're going to pull the messages.\n\n[11:09] we're then going to just put in the system message.\n\n[11:11] So this is the same as before, except I've added in you've also got\n\n[11:15] access to the Yahoo finance tool.\n\n[11:17] And then we've basically got our message, which we're going to\n\n[11:20] wrap as a human message in there.\n\n[11:22] We're going to append that to the messages.\n\n[11:24] So our message is going to have whatever our query is going in.\n\n[11:28] and then we're going to invoke it just like we did before, right.\n\n[11:31] With this LLM with tools, in there.\n\n[11:34] We set up our tools exactly the same as before.\n\n[11:37] We're just adding in this, get stock price.\n\n[11:40] we set up the LLM with and bind the tools again.\n\n[11:44] You can see if we look at the tools, we can see the new tool that we've added in\n\n[11:48] here is this fifth tool is this, get stock price and ticker and stuff like that.\n\n[11:53] We can see, okay, what's going through to the actual model there.\n\n[11:57] All right.\n\n[11:57] I've talked about, we set up our graph state in there.\n\n[12:01] Finally, we just assemble everything in here.\n\n[12:03] So I'm just calling this workflow where we're creating our state graph from\n\n[12:07] this class that we defined up here.\n\n[12:10] We add in our node for a reasoner.\n\n[12:13] We add in the tools I'm still using their pre-made, tool note,\n\n[12:16] very useful for doing that.\n\n[12:18] and then I kick it off exactly the same as using the same conditional edge.\n\n[12:22] and putting it together and you can see the graph is going to be the same as well.\n\n[12:25] It's just, I've just now got the freedom.\n\n[12:28] If I want it to not come out with end here, I could go to other nodes\n\n[12:32] and do other things in there as well.\n\n[12:35] All right, let's try it out.\n\n[12:36] So what is two times Brad Pitt's age?\n\n[12:39] Sure enough.\n\n[12:39] We get the same result back here.\n\n[12:41] I'm just looking at the last message on the stack there.\n\n[12:45] if I ask it, what is the price of Apple?\n\n[12:47] you can see sure enough, it just goes for get stock price.\n\n[12:51] uses the function calling returns that if I ask it, what is the stock price of\n\n[12:56] the company that Jensen Huang is CEO of?\n\n[12:59] So now we're starting to do multiple calls to this tool, but we're still\n\n[13:04] just using that one tool note each time.\n\n[13:06] and cause he's shown off, it says, okay.\n\n[13:08] what is stock price?\n\n[13:10] We've got Duck Duck Go search first asking Jensen Huang CEO company.\n\n[13:15] And we can see that, sure enough, it gets back from Denny's\n\n[13:17] dishwasher to CEO of Nvidia.\n\n[13:19] So it works out that it's Nvidia.\n\n[13:21] it then does a stock price call on Nvidia.\n\n[13:25] It gets back the price for that.\n\n[13:27] And then it finally gives it, then it goes back to the reasoner where it phrases\n\n[13:31] it in nice natural language for us.\n\n[13:33] The stock price of Nvidia, the company where Jensen Huang is the CEO, is this.\n\n[13:38] Again, if I wanted to use more tools, I can ask it what would be the price\n\n[13:42] of Nvidia's stock if it doubles?\n\n[13:45] Again, it's got to basically get this.\n\n[13:47] It's got this, as then using our math tools in there.\n\n[13:50] So very quickly, you can see that this really small little agent that basically\n\n[13:56] is just doing like a ReAct pattern of looping through, but doing it with\n\n[14:00] function calling is able to get a whole bunch of information and return this.\n\n[14:05] So this is something that you could even use as a sub graph where you could\n\n[14:09] basically have other graphs calling to this, you could have things in your\n\n[14:13] app that just need to know certain information, call out to this, et cetera.\n\n[14:18] And for a pretty small amount of code you've now got something\n\n[14:21] that can use a lot of different tools that you have in there.\n\n[14:24] And you'd be able to call them in a loop and then give a nice\n\n[14:26] natural language answer out there.\n\n[14:29] So, if you want using this pattern already in your agents, you certainly should be.\n\n[14:33] It's one of the easiest patterns to use.\n\n[14:35] And it generally works very well All right.\n\n[14:37] As always, if you've got any questions, please put them in the comments below.\n\n[14:40] If you found the video useful, please click like and subscribe.\n\n[14:43] And I will talk to you in the next video.\n\n[14:45] Bye for now.\r\n</transcript>",
          "source": "user",
          "id": "adcb674a-8d1d-456a-b41d-eba30009b57f",
          "isInProgress": false
        },
        "billingEvents": [
          {
            "id": "f8d7f780-fcca-4f09-bad8-d8f72e289d68",
            "rateId": "d7d16436-e2ee-4703-ba4d-4db4526c3ba1",
            "numUnits": 6141,
            "eventType": "claude-3-5-haiku-llm_inference-prompt",
            "unitPrice": 823,
            "billedAmount": 5054043
          }
        ]
      },
      {
        "id": "bca44a29-3ecc-4b81-bc7d-45272c811772",
        "source": {
          "workflowId": "c0107b5f-3f51-4d82-b850-b2b4013f133b",
          "stepId": "a3cb5849-95e1-4168-bd7d-c8c31202813e",
          "logId": "a2aa8407-0a6e-4ec8-8fd5-0de243138841",
          "idempotencyKey": null
        },
        "type": "chatMessage",
        "dateCreated": "2025-02-24T09:55:25.364724+00:00",
        "dateLastUpdated": "2025-02-24T09:55:25.364724+00:00",
        "selectedVariantId": null,
        "chatMessage": {
          "_debugInfo": {
            "modelSettings": {
              "model": "claude-3-5-haiku",
              "preamble": "/*******************************************************************************\n * YouTube Video Transcript Summarizer\n * \n * Purpose: Summarizes YouTube video transcripts, focusing on main points and key themes\n * Input: Full transcript of a YouTube video\n * Output: Clear and concise summary\n * Constraints: Omits irrelevant details and filler content\n *******************************************************************************/\n\n# Role\n\nThe Assistant summarizes the transcript of a YouTube video by identifying and distilling the main points and key themes discussed.\n\n## Task\n\nThe Assistant will read through the entire transcript and produce a summary that captures the essence of the video's message.\nThe summary must:\n- Emphasize the main points made by the speaker.\n- Clearly highlight the key themes discussed in the video.\n- Omit less relevant details and filler content.\n- Be clear and concise.\n\n## Supported Format\n\nThe summary produced by the Assistant should be in plain text format.\nThe length of the summary should be proportional to the length and complexity of the original transcript but aim to be as concise as possible while still capturing the essential information.\n\n## Response Style\n\nThe Assistant should use:\n- Precise and clear language.\n- Complete sentences that are easy to understand.\n- A neutral and objective tone, focusing only on the information presented in the video without adding any personal opinions.\n\nThe Assistant must ensure that the summary provides a coherent overview, making it easy for someone who has not seen the video to understand the main points and key themes discussed.",
              "temperature": 0.6,
              "maxResponseTokens": 8192,
              "multiModelEnabled": true,
              "userMessagePrefix": "- Human: ",
              "systemMessagePrefix": "- Assistant: "
            },
            "resolvedModelId": "claude-3-5-haiku",
            "timeResponseReceived": 1740390942593,
            "tokensSent": 6141,
            "fullPrompt": "[\n  {\n    \"role\": \"system\",\n    \"content\": \"# Role\\n\\nThe Assistant summarizes the transcript of a YouTube video by identifying and distilling the main points and key themes discussed.\\n\\n## Task\\n\\nThe Assistant will read through the entire transcript and produce a summary that captures the essence of the video's message.\\nThe summary must:\\n- Emphasize the main points made by the speaker.\\n- Clearly highlight the key themes discussed in the video.\\n- Omit less relevant details and filler content.\\n- Be clear and concise.\\n\\n## Supported Format\\n\\nThe summary produced by the Assistant should be in plain text format.\\nThe length of the summary should be proportional to the length and complexity of the original transcript but aim to be as concise as possible while still capturing the essential information.\\n\\n## Response Style\\n\\nThe Assistant should use:\\n- Precise and clear language.\\n- Complete sentences that are easy to understand.\\n- A neutral and objective tone, focusing only on the information presented in the video without adding any personal opinions.\\n\\nThe Assistant must ensure that the summary provides a coherent overview, making it easy for someone who has not seen the video to understand the main points and key themes discussed.\",\n    \"numTokens\": 246\n  },\n  {\n    \"role\": \"user\",\n    \"content\": \"Watch the full video to understand the content flow and identify natural topic transitions. Create a structured summary organized by segments, with each segment containing:\\r\\n\\r\\n- A descriptive subheading that includes timestamp range and topic (e.g. \\\"[0:00-2:15] Introduction to Topic\\\")\\r\\n- A thorough paragraph explaining the main ideas, arguments, and key takeaways\\r\\n- Direct quotes in italics when they effectively illustrate important points\\r\\n- Relevant data, statistics, or examples in bullet form\\r\\n- Transition sentences between major topic changes\\r\\n\\r\\nUse heading levels to show content hierarchy:\\r\\n- H1 (#) for video title\\r\\n- H2 (##) for major segments\\r\\n- H3 (###) for subsections within segments\\r\\n\\r\\nFormat key terms in bold when first introduced. Use bullet points for lists of related items and numbered lists for sequential steps or processes.\\r\\n\\r\\nMaintain the video's original flow while condensing repetitive content. Focus on capturing both the high-level narrative and specific supporting details that strengthen main arguments or demonstrate concepts.\\r\\n\\r\\nReview the completed summary to ensure it provides a comprehensive yet concise representation of the video's core message and learning objectives.\\r\\n\\r\\n<transcript>\\r\\n[00:00] Alright in this video, I want to teach you one of the most common, useful, simple\\n\\n[00:05] patterns that you can use in LangGraph.\\n\\n[00:08] And this is the pattern around creating ReAct agents, but\\n\\n[00:12] doing it with function calling.\\n\\n[00:14] So, this is a fundamental thing that I see a lot of people make mistakes when\\n\\n[00:18] they're designing their agents is that they end up having lots of different\\n\\n[00:22] nodes for doing different sorts of calls and function calls and stuff like that.\\n\\n[00:27] And they try to have something like a reason where it decides if it's\\n\\n[00:30] going to use math, it's going to use search, if it's going to use this.\\n\\n[00:34] And they end up with a graph, that's really complicated.\\n\\n[00:36] What you realize after this video is that really, you can just do all of this with\\n\\n[00:41] making one node yourself and then using some prebuilt functions from LangGraph.\\n\\n[00:47] So here we're going to basically have out reasoner node, which is going to\\n\\n[00:51] decide if we're going to use a tool.\\n\\n[00:52] If we're going to use a tool, no matter what the tool we're\\n\\n[00:55] going to go to the tool node.\\n\\n[00:56] we're going to take the output of that tool, feed it back to the reasoner.\\n\\n[01:00] If it decides it needs another tool, it will go again to the tool note.\\n\\n[01:04] if it decides that it doesn't need a tool at all, it will just go to the end.\\n\\n[01:08] This is one of the simplest patterns, but it's one of the most\\n\\n[01:11] useful patterns that you can use.\\n\\n[01:13] I'll start off by showing you a simple version of this.\\n\\n[01:15] And then we'll add in a custom tool and then we'll also make\\n\\n[01:18] a custom state graph for this.\\n\\n[01:19] So you can see how you can take the basics and then end up with\\n\\n[01:22] something that's fully customized for what you want at the end here.\\n\\n[01:26] Okay, so let's jump in and have a look at the code.\\n\\n[01:28] So, first off you can see, I'm just bringing in the standard\\n\\n[01:31] stuff for LangGraph and LangChain.\\n\\n[01:34] We're going to use Duck Duck Go in here.\\n\\n[01:36] And we're going to start off with just a really simple ReAct function calling\\n\\n[01:39] pattern of doing a search and math.\\n\\n[01:43] So it's going to be sort of an extension of one of the examples\\n\\n[01:46] that they give in their docs.\\n\\n[01:48] Before we do that, I wanted to show you the traditional ReAct prompt, you\\n\\n[01:53] basically are doing something where you're asking it to decide if you want to\\n\\n[01:57] use tools, you're passing in the tools.\\n\\n[02:00] So it knows what tools that has access to.\\n\\n[02:03] And then you ask it, an action step that's going to take, and it's going\\n\\n[02:06] to provide a action input for that.\\n\\n[02:09] So while technically what we're doing is not exactly the ReAct prompt,\\n\\n[02:14] we're doing the same thing with the function calling in here right.\\n\\n[02:18] And to take advantage of that in LangGraph, we need\\n\\n[02:20] to set it up the right way.\\n\\n[02:22] So first off, we're just gonna bring in a standard model in here.\\n\\n[02:26] We've just got a chat model and you don't have to use OpenAI.\\n\\n[02:28] You could use some of the other ones in here as well.\\n\\n[02:31] We're then going to set up some tools.\\n\\n[02:33] So these are the tools taken from their docs.\\n\\n[02:35] So you've got multiply.\\n\\n[02:37] You've got addition.\\n\\n[02:38] You've got divide in there.\\n\\n[02:40] and then I'm going to throw in a different tool that we're going to\\n\\n[02:43] basically just bring in the standard sort of Duck Duck Go search tool.\\n\\n[02:48] And this is the simplest search tool that you can use.\\n\\n[02:50] in a future video, I will talk a lot more about custom tools.\\n\\n[02:55] And I will talk a lot more about like crafting your own tools.\\n\\n[02:57] Although later on we'll actually make a little custom tool in here as well.\\n\\n[03:01] So we've got Duck Duck Go search.\\n\\n[03:03] You can see if I type in like how old is Brad Pitt?\\n\\n[03:06] We're going to get a bunch of information back about Brad Pitt in there.\\n\\n[03:10] And we can see that in that information is going to be his current age.\\n\\n[03:14] So next up, we want to bind those tools to the LLM, So that the definitions of\\n\\n[03:20] these tools, the schemas, et cetera, are going to go into the LLM so it\\n\\n[03:25] can use them for function calling.\\n\\n[03:26] So it can decide, okay, this is the function, or this is\\n\\n[03:29] the tool that I want to use.\\n\\n[03:31] And remember, tool use and function calling are basically the same thing.\\n\\n[03:35] It's just deciding which tool does it want to call, which is\\n\\n[03:39] the same thing as deciding which function at wants to call in here.\\n\\n[03:43] All right.\\n\\n[03:43] We set up a simple system message where we're going to have your helpful,\\n\\n[03:47] assistant performing using search and performing arithmetic on a set of inputs.\\n\\n[03:52] and then we've got the more sort of LangGraph stuff.\\n\\n[03:55] So the LangGraph stuff we need to basically define the graph.\\n\\n[03:59] We define the nodes.\\n\\n[04:01] We define the edges here.\\n\\n[04:03] Now the whole thing that I'm trying to show you with this is that you don't\\n\\n[04:07] need a lot of nodes to do this pattern.\\n\\n[04:10] So you can see that the node that I've got here is this one node the reasoner.\\n\\n[04:14] This is going to take in a message state.\\n\\n[04:16] So rather than using a type dictionary where we define everything that's going\\n\\n[04:21] to be in the state, LangGraph has made this special state called a message state.\\n\\n[04:26] And really, if we hover over it, you can see it itself is just a typed dict where\\n\\n[04:31] it's basically adding in this message.\\n\\n[04:34] and it's basically setting it up so that each time that we write\\n\\n[04:38] to it, we're not overwriting it.\\n\\n[04:39] We're just adding to the list in there.\\n\\n[04:42] So you can see that this message state, we can take the LLM that we do defined,\\n\\n[04:47] we can pass in the system message.\\n\\n[04:50] And whatever messages that the model started off with.\\n\\n[04:53] So we're going to pump in a message in there at the start.\\n\\n[04:56] And then we can just call that.\\n\\n[04:58] And then we can return that to the messages variable on here.\\n\\n[05:02] And we can see that, an addable values dict in here.\\n\\n[05:05] So that basically it's going to, whatever the response is from this, it's going to\\n\\n[05:09] basically be pushed onto this messages thing here and then that node is done.\\n\\n[05:15] It goes to the next node, or really it's going to go to the\\n\\n[05:17] next edge that we're going to see.\\n\\n[05:19] All right, so our nodes are done.\\n\\n[05:21] Now we need to build the graph.\\n\\n[05:22] So the graph here is being built where they're basically just\\n\\n[05:25] taking in the message state.\\n\\n[05:27] So this is like the pre-made dictionary for this.\\n\\n[05:31] We're then going to add the nodes to this.\\n\\n[05:33] So we're just adding, a reasoner node and we're adding in a tools node.\\n\\n[05:37] So where did this tools node come from?\\n\\n[05:40] Okay.\\n\\n[05:40] So this is one of the prebuilt things here.\\n\\n[05:42] So we're making use of two prebuilt components from LangGraph.\\n\\n[05:47] One is a tools node.\\n\\n[05:48] and can see that we just instantiate that by passing in\\n\\n[05:51] the tools that we had up here.\\n\\n[05:54] Right.\\n\\n[05:54] We've got the tools there.\\n\\n[05:56] So it knows what tools are in there.\\n\\n[05:58] It knows what tools to call, et cetera as you go through.\\n\\n[06:02] The other prebuilt thing that we've got is this tool's condition.\\n\\n[06:06] This is just a function that we're going to use in an a conditional edge so that\\n\\n[06:11] when we adding our edges, So to start we're going to go to the reasoner, this\\n\\n[06:14] is the node that basically decides, you know, sends it off and gets back with it.\\n\\n[06:19] We're going to use a function call or not a function call.\\n\\n[06:22] So if we just said hello or something like that, it's obviously not going\\n\\n[06:24] to use a function called there.\\n\\n[06:26] but if it's going to use a function call, we can see that, okay, we're\\n\\n[06:29] going to come out of that and we've got this conditional edge.\\n\\n[06:32] Now, normally the conditional edge, we would decide, okay, we're going to this\\n\\n[06:38] particular node or this other node here.\\n\\n[06:40] Now we're using this tools condition.\\n\\n[06:43] And if you look in the actual source code, you'll see that the tool's\\n\\n[06:45] condition really is no different than any conditional edge that we,\\n\\n[06:50] create ourself where it's just looking at the last message that got back\\n\\n[06:55] and if it was an AI message, it's basically saying, okay, was this using\\n\\n[07:00] tools or was this not using tools?\\n\\n[07:03] If it is using tools?\\n\\n[07:04] It's going to turn back the string tools and we can see that then\\n\\n[07:08] it's going to route it to the tool called or the tools node.\\n\\n[07:12] And if it isn't, it's going to basically just send it to the end.\\n\\n[07:15] So this is what's going on in here.\\n\\n[07:18] So it can appear a bit like it's voodoo, that you don't know what's\\n\\n[07:21] going on in there, but actually really, it's quite simple what\\n\\n[07:24] this is actually doing in here.\\n\\n[07:26] Next up, we've basically got our last edge, which will always\\n\\n[07:29] go from tools back to reasoner.\\n\\n[07:31] So once we, get told to do the function call and do a search, we go off to tools.\\n\\n[07:37] We do the search, we get the results of the search.\\n\\n[07:39] We pass it back to the model.\\n\\n[07:41] And because we're passing in the history as we go along with this, right.\\n\\n[07:45] We're passing in all of these messages.\\n\\n[07:48] It knows, oh, okay, I asked for this particular function call and this is\\n\\n[07:52] the result that I got back in there.\\n\\n[07:55] So when we put it all together, you can see that with just got\\n\\n[07:58] a very simple graph, right?\\n\\n[08:00] We're just going start to the reasoner, reasoner if it say\\n\\n[08:03] hello, we'll just go to end.\\n\\n[08:05] If you've got a tool use, it we'll go to tools and then we'll pass that back.\\n\\n[08:10] Now here's the thing is if it needs another tool call,\\n\\n[08:13] it will then just go tools.\\n\\n[08:15] So it's got this loop going on here.\\n\\n[08:18] And we can see this when we come and run it that now if I ask it, okay,\\n\\n[08:22] what is two times Brad Pitt's age?\\n\\n[08:25] So we know that we've got searched that can get Brad Pitt's age.\\n\\n[08:28] We know that we've got arithmetic that can put it together.\\n\\n[08:32] Sure enough, when we look at the messages out, we can see that what did it first do?\\n\\n[08:36] It first went and did a query to search on Duck Duck Go Brad Pitt's age, right?\\n\\n[08:41] It got that result back.\\n\\n[08:43] This is the tool message that it got back.\\n\\n[08:45] we can see then it decided his age is 60, which I think is correct\\n\\n[08:50] based on December 16th, 1963.\\n\\n[08:53] Even though it's saying 61 here.\\n\\n[08:55] And it's basically done two times that's the key thing I want you to see there.\\n\\n[08:59] And then it comes back with, the answer of that is 120.\\n\\n[09:02] And so we get this answer out, two times Brad Pitt's age, is 120 there.\\n\\n[09:06] So this idea of this tool loop going on is the key thing.\\n\\n[09:11] Now, if I only needed one tool, it would just use that and it would then end,\\n\\n[09:15] or after the final sort of call there.\\n\\n[09:18] Let's look a little bit more advanced way of adding our own custom tool.\\n\\n[09:22] So I'm going to keep the tools that we've got here.\\n\\n[09:24] I'm going to make a Yahoo finance tool.\\n\\n[09:27] So this is basically just a get a stock price based on a ticker symbol.\\n\\n[09:32] You can see that, okay, I'm just passing this in here.\\n\\n[09:35] I was experimenting with different things passing in here.\\n\\n[09:38] It seems to work well when you pass in the args that you want\\n\\n[09:41] as well, rather than just this.\\n\\n[09:44] So what we'r e going to do is we're going to get the ticker.\\n\\n[09:46] We're going to look up the stock.\\n\\n[09:47] We're going to get the previous close for that and return it.\\n\\n[09:50] You can see here if we test it.\\n\\n[09:52] we're going to get out the last Apple price in there.\\n\\n[09:55] Now LangChain has a Yahoo finance tool.\\n\\n[10:00] but I find this not to work very well.\\n\\n[10:02] You end up getting lots of news back other things.\\n\\n[10:05] It tends to confuse things in there.\\n\\n[10:07] All right.\\n\\n[10:08] This time, I want to show you, is that what if we wanted to do\\n\\n[10:12] things a little bit differently?\\n\\n[10:14] What if we want it to make our own node and our own graph in there.\\n\\n[10:17] So not using they're pre-made graph in there.\\n\\n[10:21] So okay, making the graph, let me jump around a little bit.\\n\\n[10:23] The graph here, I'm going to say, okay, we've got a query that we start things\\n\\n[10:27] off where we're going to have the messages exactly like they have in there.\\n\\n[10:31] This whole idea of an annotated list.\\n\\n[10:34] and this ad operator, you'll see this used a lot for intermediate steps.\\n\\n[10:38] but this ad operator also can just add in all the messages we've got.\\n\\n[10:42] And then we've got our final answer out.\\n\\n[10:44] you could imagine we could add some things like finance in there.\\n\\n[10:47] If we want it to save the numbers and, push them off to something\\n\\n[10:50] or do something else with it.\\n\\n[10:52] but I want to show you that can make your own custom graph dictionary there.\\n\\n[10:56] And then using this on our reasoner node.\\n\\n[10:59] Cause I just want to have the same number of nodes that we had before.\\n\\n[11:02] I'm not going to try and make a lot of them.\\n\\n[11:05] we're going to basically pull the query.\\n\\n[11:07] we're going to pull the messages.\\n\\n[11:09] we're then going to just put in the system message.\\n\\n[11:11] So this is the same as before, except I've added in you've also got\\n\\n[11:15] access to the Yahoo finance tool.\\n\\n[11:17] And then we've basically got our message, which we're going to\\n\\n[11:20] wrap as a human message in there.\\n\\n[11:22] We're going to append that to the messages.\\n\\n[11:24] So our message is going to have whatever our query is going in.\\n\\n[11:28] and then we're going to invoke it just like we did before, right.\\n\\n[11:31] With this LLM with tools, in there.\\n\\n[11:34] We set up our tools exactly the same as before.\\n\\n[11:37] We're just adding in this, get stock price.\\n\\n[11:40] we set up the LLM with and bind the tools again.\\n\\n[11:44] You can see if we look at the tools, we can see the new tool that we've added in\\n\\n[11:48] here is this fifth tool is this, get stock price and ticker and stuff like that.\\n\\n[11:53] We can see, okay, what's going through to the actual model there.\\n\\n[11:57] All right.\\n\\n[11:57] I've talked about, we set up our graph state in there.\\n\\n[12:01] Finally, we just assemble everything in here.\\n\\n[12:03] So I'm just calling this workflow where we're creating our state graph from\\n\\n[12:07] this class that we defined up here.\\n\\n[12:10] We add in our node for a reasoner.\\n\\n[12:13] We add in the tools I'm still using their pre-made, tool note,\\n\\n[12:16] very useful for doing that.\\n\\n[12:18] and then I kick it off exactly the same as using the same conditional edge.\\n\\n[12:22] and putting it together and you can see the graph is going to be the same as well.\\n\\n[12:25] It's just, I've just now got the freedom.\\n\\n[12:28] If I want it to not come out with end here, I could go to other nodes\\n\\n[12:32] and do other things in there as well.\\n\\n[12:35] All right, let's try it out.\\n\\n[12:36] So what is two times Brad Pitt's age?\\n\\n[12:39] Sure enough.\\n\\n[12:39] We get the same result back here.\\n\\n[12:41] I'm just looking at the last message on the stack there.\\n\\n[12:45] if I ask it, what is the price of Apple?\\n\\n[12:47] you can see sure enough, it just goes for get stock price.\\n\\n[12:51] uses the function calling returns that if I ask it, what is the stock price of\\n\\n[12:56] the company that Jensen Huang is CEO of?\\n\\n[12:59] So now we're starting to do multiple calls to this tool, but we're still\\n\\n[13:04] just using that one tool note each time.\\n\\n[13:06] and cause he's shown off, it says, okay.\\n\\n[13:08] what is stock price?\\n\\n[13:10] We've got Duck Duck Go search first asking Jensen Huang CEO company.\\n\\n[13:15] And we can see that, sure enough, it gets back from Denny's\\n\\n[13:17] dishwasher to CEO of Nvidia.\\n\\n[13:19] So it works out that it's Nvidia.\\n\\n[13:21] it then does a stock price call on Nvidia.\\n\\n[13:25] It gets back the price for that.\\n\\n[13:27] And then it finally gives it, then it goes back to the reasoner where it phrases\\n\\n[13:31] it in nice natural language for us.\\n\\n[13:33] The stock price of Nvidia, the company where Jensen Huang is the CEO, is this.\\n\\n[13:38] Again, if I wanted to use more tools, I can ask it what would be the price\\n\\n[13:42] of Nvidia's stock if it doubles?\\n\\n[13:45] Again, it's got to basically get this.\\n\\n[13:47] It's got this, as then using our math tools in there.\\n\\n[13:50] So very quickly, you can see that this really small little agent that basically\\n\\n[13:56] is just doing like a ReAct pattern of looping through, but doing it with\\n\\n[14:00] function calling is able to get a whole bunch of information and return this.\\n\\n[14:05] So this is something that you could even use as a sub graph where you could\\n\\n[14:09] basically have other graphs calling to this, you could have things in your\\n\\n[14:13] app that just need to know certain information, call out to this, et cetera.\\n\\n[14:18] And for a pretty small amount of code you've now got something\\n\\n[14:21] that can use a lot of different tools that you have in there.\\n\\n[14:24] And you'd be able to call them in a loop and then give a nice\\n\\n[14:26] natural language answer out there.\\n\\n[14:29] So, if you want using this pattern already in your agents, you certainly should be.\\n\\n[14:33] It's one of the easiest patterns to use.\\n\\n[14:35] And it generally works very well All right.\\n\\n[14:37] As always, if you've got any questions, please put them in the comments below.\\n\\n[14:40] If you found the video useful, please click like and subscribe.\\n\\n[14:43] And I will talk to you in the next video.\\n\\n[14:45] Bye for now.\\r\\n</transcript>\",\n    \"numTokens\": 5895\n  }\n]",
            "requestedModelId": "claude-3-5-haiku",
            "timeFirstTokenReceived": 1740390927413,
            "timeRequestSent": 1740390925536,
            "tokensReceived": 601
          },
          "loggingEnabled": false,
          "dateSent": 1740390927,
          "_presentationInfo": {
            "messageSource": "automation"
          },
          "_metadata": {
            "groupId": "fa08bddf-60b1-444f-9cfc-35fd0f68aa71",
            "citations": [],
            "workflowId": "c0107b5f-3f51-4d82-b850-b2b4013f133b",
            "automationId": "a3cb5849-95e1-4168-bd7d-c8c31202813e"
          },
          "tokensUsed": 601,
          "content": "# LangGraph ReAct Agent Pattern: Function Calling and Tool Use\n\n## [0:00-1:22] Introduction to ReAct Agent Pattern\n\nThe video introduces a fundamental pattern in LangGraph for creating **ReAct agents** using function calling. The key insight is simplifying agent design by:\n\n- Avoiding complex multi-node graphs\n- Using a single reasoner node\n- Leveraging prebuilt LangGraph functions\n- Creating a straightforward tool-use loop\n\n*\"What you realize after this video is that really, you can just do all of this with making one node yourself and then using some prebuilt functions from LangGraph.\"*\n\nCore pattern components:\n1. Reasoner node decides tool usage\n2. Tool node executes specific functions\n3. Continuous loop between reasoner and tool nodes\n4. Automatic termination when no tools are needed\n\n## [1:28-3:10] Setting Up Tools and Language Model\n\nThe demonstration uses:\n- OpenAI chat model\n- Predefined tools:\n  * Multiplication\n  * Addition\n  * Division\n  * Duck Duck Go search\n\n**Key Setup Steps**:\n1. Bind tools to the language model\n2. Create system message defining agent capabilities\n3. Enable function calling for tool selection\n\n*\"Tool use and function calling are basically the same thing - deciding which tool or function to call.\"*\n\n## [3:55-7:55] LangGraph Graph Construction\n\n### Graph Components\n- **Message State**: Specialized dictionary for storing conversation history\n- Nodes:\n  * Reasoner node\n  * Prebuilt tools node\n- Conditional edges for routing\n\n### Workflow\n1. Start at reasoner node\n2. Determine tool usage\n3. Route to tools node if needed\n4. Return results to reasoner\n5. Repeat or terminate\n\n*\"This idea of this tool loop going on is the key thing.\"*\n\n## [9:22-14:26] Advanced Example: Custom Tool Integration\n\n### Custom Yahoo Finance Tool\n- Retrieve stock prices using ticker symbols\n- Demonstrate flexibility of agent pattern\n- Show multi-step reasoning capabilities\n\n**Example Scenarios**:\n- Calculate two times Brad Pitt's age\n- Find stock price of Nvidia\n- Perform complex multi-tool queries\n\n## Key Takeaways\n\n1. Simplify agent design with minimal nodes\n2. Leverage function calling for tool selection\n3. Create flexible, reusable agent patterns\n4. Enable complex reasoning with simple architecture\n\n*\"For a pretty small amount of code you've now got something that can use a lot of different tools... and give a nice natural language answer.\"*\n\n## Recommended Practices\n\n- Use prebuilt LangGraph components\n- Design agents with single reasoner node\n- Implement conditional routing\n- Focus on tool flexibility",
          "source": "system",
          "id": "c0256644-a148-46c4-bfe5-3d1e40583e59",
          "isInProgress": false
        },
        "billingEvents": [
          {
            "id": "433ce851-4b99-4016-8185-517d2bdc3a6d",
            "rateId": "2f27183e-6869-4ab8-a56c-f4761fd75790",
            "numUnits": 601,
            "eventType": "claude-3-5-haiku-llm_inference-response",
            "unitPrice": 4116,
            "billedAmount": 2473716
          }
        ]
      }
    ]
  }
]